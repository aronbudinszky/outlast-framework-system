/**
 * Define this data attribute.
 * @attr data-action-name Unique action name (default: autogenerated)
 * @attr data-action-type Action type (can be: 'toggle'|'add'|'remove'|'set', default: 'toggle')
 * @attr data-action-value String value which will affect the attribute value of the destination DOM element(s) (required)
 * @attr data-action-value-type The attribute value of the destination DOM element(s) can be a "static" string, or the name of an "attribute" of the source DOM element which stores the value (can be 'static'|'attribute')
 * @attr data-action-event jQuery/custom event fires up action (default: 'click')
 * @attr data-action-event-threshold Custom event (swipe) threshold value (default: 10)
 * @attr data-action-source-selector A selector which determines the source DOM element(s) (default: this)
 * @attr data-action-destination-selector A selector which determines the destination DOM element(s) (default: this)
 * @attr data-action-trigger-before Action will trigger before this named action, which has the same source selector (default: false)
 * @attr data-action-trigger-before Action will trigger after this named action, which has the same source selector (default: false)
 * @attr data-action-destination-selector A selector which determines the destination DOM element(s) (default: this)
 * @attr data-action-attribute The attribute of the destination DOM element (default: 'class')
 * @attr data-action-interval-time Time of the function calling interval (in milliseconds). Used at custom scroll event checking (default: 100).
 * @attr data-action-extra-condition Function call which determines extra condition for the execution of the action (default: true)
 **/
define('system/js/data/action-value', ["../ofw-jquery"], function() {

    /** Properties **/
    var scrollInterval = null;
    var scrollElements = [];
    var isIOS;
    var touchPositions = {
        startX: null,
        startY: null,
        currentX: null,
        currentY: null
    };

    // data-action-* attribute defaults
    var elementDefaults = {
        type: 'toggle',
        source_selector: null,
        destination_selector: null,
        event: 'click',
        event_threshold: 10,
        attribute: 'class',
        value: null,
        value_type: 'static',
        trigger_before: false,
        trigger_after: false,
        interval_time: 100,
        extra_condition: (function () {return true})
    };

    // data-action-name counter (if data-action-name is not present)
    var elementNameCounter = 0;

    // currently triggering actions queue
    var actionQueue = {};

    var actionOrder = [];

    var actionCheckInProgress = false;

    /** Private API **/

    /**
     * Object init
     */
    var init = function(){
        isIOS = checkIOS(); // Add any init here
    };

    /**
     * iOS platform check
     *
     * @returns {boolean}
     */
    function checkIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    }

    /**
     * Trigger custom swipe events
     * @param {object} element Element data object
     */
    var handleSwipeEvent = function(element) {

        var touchStarted = false;
        var _events = [];

        $(document).on('touchstart', element.sourceElm, function(e) {
            var pointer = getPointerEvent(e);

            // caching the current x
            touchPositions.startX = touchPositions.currentX = pointer.pageX;
            touchPositions.startY = touchPositions.currentY = pointer.pageY;

            // a touch event is detected
            touchStarted = true;

            // detecting if after 200ms the finger is still in the same position
            setTimeout(function (){
                if ((touchPositions.startX === touchPositions.currentX) && !touchStarted && (touchPositions.startY === touchPositions.currentY)) {
                    touchStarted = false;
                }
            },200);
        });

        $(document).on('touchmove', element.sourceElm, function(e) {
            var pointer = getPointerEvent(e);

            _events = [];

            touchPositions.currentX = pointer.pageX;
            touchPositions.currentY = pointer.pageY;

            if (touchPositions.currentX + element.event_threshold < touchPositions.startX) {
                _events.push('swipeleft');
            } else if (touchPositions.currentX - element.event_threshold > touchPositions.startX) {
                _events.push('swiperight');
            }

            if (touchPositions.currentY + element.event_threshold < touchPositions.startY) {
                _events.push('swipeup');
            } else if (touchPositions.currentY - element.event_threshold > touchPositions.startY) {
                _events.push('swipedown');
            }

        });

        $(document).on('touchend touchcancel', element.sourceElm, function(e) {

            if (touchStarted && _events.length) {

                var event_idx = _events.indexOf(element.event);

                if (event_idx > -1 && element.extra_condition()) {
                    element.sourceElm.trigger(_events[event_idx]);
                }
            }

            // here we can consider finished the touch event
            touchStarted = false;
            _events = [];
        });
    };

    /**
     * Custom scroll event checking
     *
     * @param {int} index The index of the current scroll_element (from scrollElements)
     * @return {boolean} True if scroll event condition is fulfilled, false if not
     */
    var checkScrollEvent = function(index) {

        var condition, direction;
        var element = scrollElements[index];

        // Browser's top position bouncing is not a scroll event
        if (element.sourceElm.scrollTop() < 0 || element.sourceElm.scrollTop() + element.sourceElm.outerHeight() > $(document).height()) {
            return false;
        }

        switch (element.event) {
            case 'scroll-start':
                condition = (null === element.lastY && element.sourceElm.scrollTop() > 0);
                break;
            case 'scroll-end':
                condition = (element.lastY == element.sourceElm.scrollTop());
                break;
            case 'scroll':
                condition = (null !== element.lastY && element.lastY != element.sourceElm.scrollTop());
                break;
            case 'scroll-up':
                condition = (null !== element.lastY && element.lastY < element.sourceElm.scrollTop());
                break;
            case 'scroll-down':
                condition = (null !== element.lastY && element.lastY > element.sourceElm.scrollTop());
                break;
            case 'scroll-dir-change':
                condition = (null !== element.lastY && ((element.direction != 1 && element.lastY < element.sourceElm.scrollTop()) || (element.direction != -1 && element.lastY > element.sourceElm.scrollTop())));
                break;
            case 'scroll-dir-change-up':
                condition = (null !== element.lastY && element.direction != 1 && element.lastY < element.sourceElm.scrollTop());
                break;
            case 'scroll-dir-change-down':
                condition = (null !== element.lastY && element.direction != -1 && element.lastY > element.sourceElm.scrollTop());
                break;
            case 'scroll-reached-top':
                condition = (null !== element.lastY && element.direction != 1 && element.sourceElm.scrollTop() == 0);
                break;
            case 'scroll-reached-bottom':
                condition = (null !== element.lastY && element.direction != -1 && element.sourceElm.scrollTop() + element.scrollContainer.height() == element.scrollContent.height());
                break;

        }

        if (element.lastY < element.sourceElm.scrollTop()) {
            direction = 1;
        } else if (element.lastY > element.sourceElm.scrollTop()) {
            direction = -1;
        } else {
            direction = null;
        }

        scrollElements[index].direction = direction;
        scrollElements[index].lastY = (element.event == 'scroll-end') ? null : element.sourceElm.scrollTop();

        return (element.extra_condition() && condition);
    };

    /**
     * Add an action to the queue
     *
     * @param {object|int} element The element object/index of the current scroll_element (from scrollElements)
     * @param {object} _this The DOM element of the current source element
     */
    var addToActionQueue = function(element, _this) {

        if (undefined === actionQueue[element.name]) {

            actionQueue[element.name] = {
                _this: _this,
                element: element
            };

            actionOrder.push(element.name);

            // The "call after all events" hack
            window.setTimeout(function() {
                if (!actionCheckInProgress && actionOrder.length > 0) {
                    actionCheckInProgress = true;
                    sortActions();
                }
            }, 0);
        }
    };

    /**
     * Reset action queue and order
     */
    var resetActionQueue = function() {
        actionQueue = {};
        actionOrder = [];

        actionCheckInProgress = false;
    };

    /**
     * Sort triggering actions
     *
     */
    var sortActions = function() {
        var element_name;

        for (var idx in actionOrder) {

            element_name = actionOrder[idx];
            element = actionQueue[element_name].element;

            if (element.trigger_before && actionOrder.indexOf(element.trigger_before) > -1 && actionOrder.indexOf(element_name) > actionOrder.indexOf(element.trigger_before)) {
                delete actionOrder[idx];
                actionOrder.splice(actionOrder.indexOf(element.trigger_before), 0, element_name);
            }
            else if (element.trigger_after && actionOrder.indexOf(element.trigger_after) > -1 && actionOrder.indexOf(element_name) < actionOrder.indexOf(element.trigger_after)) {
                delete actionOrder[idx];
                actionOrder.splice(actionOrder.indexOf(element.trigger_after) + 1, 0, element_name);
            }
        }

        triggerActions();
    };

    /**
     * Trigger all actions from the queue
     *
     */
    var triggerActions = function() {

        var action;

        for (var idx in actionOrder) {
            action = actionQueue[actionOrder[idx]];

            triggerAction(action.element, action._this);
        }

        resetActionQueue();
    };

    /**
     * Trigger an action
     *
     * @param {object|int} element The element object/index of the current scroll_element (from scrollElements)
     * @param {object} _this The DOM element of the current source element
     */
    var triggerAction = function(element, _this) {

        if (typeof element != 'object') {
            element = scrollElements[element];
        }

        var $this,
            attr,
            values,
            value,
            value_data,
            current_values,
            current_idx,
            action_needed,
            action_value;

        // get value from source's attribute if present
        if (element.value_type == 'attribute' && _this.attr(element.value).length) {
            value_data = _this.attr(element.value);
        } else {
            value_data = element.value;
        }

        values = value_data.split(",");

        for (var idx in values) {

            value = values[idx].trim();

            element.destElm.each(function () {

                action_needed = true;

                $this = (element.destination_selector === null) ? _this : $(this);

                attr = $this.attr(element.attribute);

                if (undefined !== attr) {
                    current_values = attr.split(" ");
                    current_idx = current_values.indexOf(value);
                } else {
                    current_values = null;
                    current_idx = -1;
                }

                if (element.type != 'set') {
                    if (element.type != 'remove' && current_idx < 0) {
                        action_value = ((attr !== undefined && attr.length > 0) ? attr + ' ' : '') + value;
                    }
                    else if (element.type != 'add' && current_idx > -1) {
                        current_values.splice(current_idx, 1);
                        action_value = current_values.join(" ");
                    } else {
                        action_needed = false;
                    }
                } else {
                    action_value = value;
                }

                if (action_needed) {
                    $(this).attr(element.attribute, action_value);
                }
            });
        }
    };

    /**
     * Cross-browser pointer event getter
     *
     * @param {Event} event
     * @returns {Event}
     */
    var getPointerEvent = function (event) {
        return event.originalEvent.targetTouches ? event.originalEvent.targetTouches[0] : event;
    };

    /**
     * Get DOM element object for dynamic $(element).on(..) usage
     *
     * @param {string} source_selector Source selector string
     * @returns {object} DOM object
     */
    var getOnDOMElement = function (source_selector) {
        if (source_selector == 'window') {
            return window;
        } else {
            return document;
        }
    };

    /**
     * Cross-platform event initialization
     *
     * @param {jQuery|Array} $elements An array of jQuery objects that have the data attribute.
     * @param {jQuery} [$context=$(document)] The current jQuery object context in which the handlers are searched for.
     */
    var initCrossPlatformEvents = function($elements, $context) {
        // Cross-browser transition end event trigger
        if ($context.find('[data-action-event="trans-end"]').length) {
            $(document).on('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', '[data-action-event="trans-end"]', function () {
                $(this).trigger('trans-end');
            });
        }
        if ($context.find('[data-action-event="anim-end"]').length) {
            // Cross-browser animation end event trigger
            $(document).on('animationend webkitAnimationEnd oAnimationEnd MSAnimationEnd', '[data-action-event="anim-end"]', function () {
                $(this).trigger('anim-end');
            });
        }
    };

    /**
     * Element data object creator
     *
     * @param {jQuery} $el jQuery DOM element of an action element
     * @returns {object}
     */
    var setElementData = function($el) {

        var data_attribute_name, value, element_name;

        if ($el.data('action-name')) {
            element_name = $el.data('action-name');
        }
        else {
            element_name = 'action' + elementNameCounter;
            elementNameCounter++;
        }

        var element = {name: element_name};

        // set element object properties
        for (var attribute in elementDefaults) {

            data_attribute_name = 'action-' + attribute.replace('_', '-');

            if ($el.data(data_attribute_name)) {

                switch (typeof elementDefaults[attribute]) {
                    case 'number':
                        value = parseInt($el.data(data_attribute_name));
                        break;
                    case 'function':
                        value = window[$el.data(data_attribute_name)];
                        break;
                    default:
                        value = $el.data(data_attribute_name);
                        break;

                }
            }
            else {
                value = elementDefaults[attribute];
            }

            element[attribute] = value;
        }

        // Handle special selectors (window/document)
        switch (element.source_selector) {
            case 'window':
                element.sourceElm = $(window);
                break;
            case 'document':
                element.sourceElm = $(document);
                break;
            case null:
                element.sourceElm = $el;
                break;
            default:
                element.sourceElm = $(element.source_selector);
        }

        // iOS click tirgger hack
        if (isIOS && element.source_selector != 'window' && element.source_selector != 'document' && element.event == 'click') {
            element.sourceElm.css('cursor', 'pointer');
        }

        element.destElm = (element.destination_selector !== null) ? $(element.destination_selector) : element.sourceElm;
        
        return element;
    };

    /**
     * Handle action triggering according to action type
     *
     * @param element
     */
    var handleActionTriggering = function(element) {
        var onElm;

        // Scroll event
        if (element.event.indexOf('scroll') > -1) {
            // Scroll event
            element.lastY = null;
            element.direction = null;
            element.scrollContent = (element.source_selector == 'window' || element.source_selector == 'document') ? $(document) : element.sourceElm;
            element.scrollContainer = (element.source_selector == 'window' || element.source_selector == 'document') ? $(window) : element.sourceElm.parent();

            scrollElements.push(element);

            element.scrollContainer.on('touchstart mousedown', function () {

                if (null === scrollInterval) {
                    scrollInterval = setInterval(function () {
                        for (var index in scrollElements) {
                            if (checkScrollEvent(index)) {
                                addToActionQueue(index);
                            }
                        }
                    }, element.interval_time);
                }
            });

            element.scrollContainer.on('touchend touchcancel mouseup', function () {

                if (null !== scrollInterval) {
                    clearInterval(scrollInterval);
                    scrollInterval = null;
                }
            });

        }// Swipe event
        else if (element.event.indexOf('swipe') > -1) {

            handleSwipeEvent(element);
            onElm = getOnDOMElement(element.source_selector);

            if (element.source_selector !== null) {
                $(onElm).on(element.event, element.source_selector, function (event) {
                    addToActionQueue(element, $(event.target));
                });
            } else {
                element.sourceElm.on(element.event, function () {
                    addToActionQueue(element, $(this));
                });
            }
        }
        else {
            // Other standard event
            onElm = getOnDOMElement(element.source_selector);

            if (element.source_selector !== null) {
                $(onElm).on(element.event, element.source_selector, function (event) {
                    if (element.extra_condition()) {
                        addToActionQueue(element, $(event.target));
                    }
                });
            } else {
                $(element.sourceElm).on(element.event, function () {

                    if (element.extra_condition()) {
                        addToActionQueue(element, $(this));
                    }
                });
            }
        }
    };


    /** Public API **/

    var api = {

        /**
         * Activate all the data attributes in this context.
         * @param {jQuery|Array} $elements An array of jQuery objects that have the data attribute.
         * @param {jQuery} [$context=$(document)] The current jQuery object context in which the handlers are searched for.
         */
        activate: function ($elements, $context) {

            initCrossPlatformEvents($elements, $context);

            $elements.each(function () {
                var $el = $(this);

                if (!$el.data('action-value')) return;

                // Element data object
                var element = setElementData($el);

                handleActionTriggering(element);
            });
        }

    };

    /** Perform initialization **/
    init();

    // Return my external API
    return api;

});